// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class NameRegistered extends ethereum.Event {
  get params(): NameRegistered__Params {
    return new NameRegistered__Params(this);
  }
}

export class NameRegistered__Params {
  _event: NameRegistered;

  constructor(event: NameRegistered) {
    this._event = event;
  }

  get name(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get stealthMetaAddress(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class MetaAddressUpdated extends ethereum.Event {
  get params(): MetaAddressUpdated__Params {
    return new MetaAddressUpdated__Params(this);
  }
}

export class MetaAddressUpdated__Params {
  _event: MetaAddressUpdated;

  constructor(event: MetaAddressUpdated) {
    this._event = event;
  }

  get name(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get newMetaAddress(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class NameTransferred extends ethereum.Event {
  get params(): NameTransferred__Params {
    return new NameTransferred__Params(this);
  }
}

export class NameTransferred__Params {
  _event: NameTransferred;

  constructor(event: NameTransferred) {
    this._event = event;
  }

  get name(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get previousOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class NameRegistry extends ethereum.SmartContract {
  static bind(address: Address): NameRegistry {
    return new NameRegistry("NameRegistry", address);
  }

  hashToName(param0: Bytes): string {
    let result = super.call("hashToName", "hashToName(bytes32):(string)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);

    return result[0].toString();
  }

  try_hashToName(param0: Bytes): ethereum.CallResult<string> {
    let result = super.tryCall("hashToName", "hashToName(bytes32):(string)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  nameOwner(param0: Bytes): Address {
    let result = super.call("nameOwner", "nameOwner(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);

    return result[0].toAddress();
  }

  try_nameOwner(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("nameOwner", "nameOwner(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getNamesOwnedBy(owner: Address): Array<string> {
    let result = super.call(
      "getNamesOwnedBy",
      "getNamesOwnedBy(address):(string[])",
      [ethereum.Value.fromAddress(owner)],
    );

    return result[0].toStringArray();
  }

  try_getNamesOwnedBy(owner: Address): ethereum.CallResult<Array<string>> {
    let result = super.tryCall(
      "getNamesOwnedBy",
      "getNamesOwnedBy(address):(string[])",
      [ethereum.Value.fromAddress(owner)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toStringArray());
  }
}
